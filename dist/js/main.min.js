/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nlet burgerButton = document.querySelector(\".burger-button\");\nlet crossButton = document.querySelector(\".cross-button\");\nlet mobileMenu = document.querySelector(\".mobile-menu\");\nburgerButton.addEventListener(\"click\", (event) => {\n  if (mobileMenu) {\n    mobileMenu.style.display = \"block\";\n    burgerButton.classList.toggle(\"hidden-mobile\");\n    document.body.classList.toggle(\"scroll-lock\");\n    mobileMenu.classList.remove(\"animation-close\");\n    mobileMenu.classList.add(\"animation-open\");\n  }\n});\ncrossButton.addEventListener(\"click\", (event) => {\n  burgerButton.classList.toggle(\"hidden-mobile\");\n  document.body.classList.toggle(\"scroll-lock\");\n  mobileMenu.classList.remove(\"animation-open\");\n  mobileMenu.classList.add(\"animation-close\");\n});\nconst links = document.querySelectorAll(\"a[href^='#']\");\nfor (let link of links) {\n  link.addEventListener(\"click\", (e) => {\n    e.preventDefault();\n    const id = link.getAttribute(\"href\");\n    document.querySelector(id).scrollIntoView({\n      behavior: \"smooth\",\n      block: \"start\"\n    });\n  });\n}\n;\n/**\n * @class ItcSlider\n * @version 1.0.1\n * @author https://github.com/itchief\n * @copyright Alexander Maltsev 2020 - 2023\n * @license MIT (https://github.com/itchief/ui-components/blob/master/LICENSE)\n * @tutorial https://itchief.ru/javascript/slider\n */\nclass ItcSlider {\n  /**\n   * @param {HTMLElement} el\n   * @param {Object} config\n   * @param {String} prefix\n   */\n  constructor(el, config = {}, prefix = \"itc-slider-\") {\n    __publicField(this, \"config\");\n    __publicField(this, \"state\");\n    this.state = {\n      prefix,\n      // префикс для классов\n      el,\n      // элемент который нужно активировать как ItcSlider\n      elWrapper: el.querySelector(`.${prefix}${this.constructor.EL_WRAPPER}`),\n      // элемент с CLASS_WRAPPER\n      elItems: el.querySelector(`.${prefix}${this.constructor.EL_ITEMS}`),\n      // элемент, в котором находятся слайды\n      elListItem: el.querySelectorAll(`.${prefix}${this.constructor.EL_ITEM}`),\n      // список элементов, являющиеся слайдами\n      btnPrev: el.querySelector(`.${prefix}${this.constructor.BTN_PREV}`),\n      // кнопка, для перехода к предыдущему слайду\n      btnNext: el.querySelector(`.${prefix}${this.constructor.BTN_NEXT}`),\n      // кнопка, для перехода к следующему слайду\n      btnClassHide: prefix + this.constructor.BTN_HIDE,\n      // класс для скрытия кнопки\n      exOrderMin: 0,\n      exOrderMax: 0,\n      exItemMin: null,\n      exItemMax: null,\n      exTranslateMin: 0,\n      exTranslateMax: 0,\n      direction: \"next\",\n      // направление смены слайдов\n      intervalId: null,\n      // id таймера\n      isSwiping: false,\n      swipeX: 0,\n      swipeY: 0\n    };\n    this.config = __spreadValues({\n      loop: true,\n      direction: \"next\",\n      autoplay: false,\n      interval: 5e3,\n      refresh: true,\n      swipe: true\n    }, config);\n    this.init();\n    this.attachEvents();\n  }\n  static checkSupportPassiveEvents() {\n    let passiveSupported = false;\n    try {\n      const options = Object.defineProperty({}, \"passive\", {\n        get() {\n          passiveSupported = true;\n        }\n      });\n      window.addEventListener(\"testPassiveListener\", null, options);\n      window.removeEventListener(\"testPassiveListener\", null, options);\n    } catch (error) {\n      passiveSupported = false;\n    }\n    return passiveSupported;\n  }\n  /**\n   * Статический метод, который возвращает экземпляр ItcSlider, связанный с DOM-элементом\n   * @param {HTMLElement} elSlider\n   * @returns {?ItcSlider}\n   */\n  static getInstance(elSlider) {\n    const found = this.instances.find((el) => el.target === elSlider);\n    if (found) {\n      return found.instance;\n    }\n    return null;\n  }\n  /**\n   * @param {String|HTMLElement} target\n   * @param {Object} config\n   * @param {String} prefix\n   */\n  static getOrCreateInstance(target, config = {}, prefix = \"itc-slider-\") {\n    const elSlider = typeof target === \"string\" ? document.querySelector(target) : target;\n    const result = this.getInstance(elSlider);\n    if (result) {\n      return result;\n    }\n    const slider = new this(elSlider, config, prefix);\n    this.instances.push({ target: elSlider, instance: slider });\n    return slider;\n  }\n  // статический метод для активирования элементов как ItcSlider на основе data-атрибутов\n  static createInstances() {\n    document.querySelectorAll('[data-slider=\"itc-slider\"]').forEach((el) => {\n      const { dataset } = el;\n      const params = {};\n      Object.keys(dataset).forEach((key) => {\n        if (key === \"slider\") {\n          return;\n        }\n        let value = dataset[key];\n        value = Number.isNaN(Number(value)) ? value : Number(value);\n        value = value === \"true\" ? true : value;\n        value = value === \"false\" ? false : value;\n        params[key] = value;\n      });\n      this.getOrCreateInstance(el, params);\n    });\n  }\n  slideNext() {\n    this.state.direction = \"next\";\n    this.move();\n  }\n  slidePrev() {\n    this.state.direction = \"prev\";\n    this.move();\n  }\n  slideTo(index) {\n    this.moveTo(index);\n  }\n  reset() {\n    this.reset();\n  }\n  get autoplay() {\n    return {\n      // Start autoplay\n      start: () => {\n        this.config.autoplay = true;\n        this.autoplay();\n      },\n      // Stop autoplay\n      stop: () => {\n        this.autoplay(\"stop\");\n        this.config.autoplay = false;\n      }\n    };\n  }\n  dispose() {\n    this.detachEvents();\n    const transitionNoneClass = this.state.prefix + this.constructor.TRANSITION_NONE;\n    const activeClass = this.state.prefix + this.constructor.EL_ITEM_ACTIVE;\n    this.autoplay(\"stop\");\n    this.state.elItems.classList.add(transitionNoneClass);\n    this.state.elItems.style.transform = \"\";\n    this.state.elListItem.forEach((el) => {\n      el.style.transform = \"\";\n      el.classList.remove(activeClass);\n    });\n    const selIndicators = `${this.state.prefix}${this.constructor.EL_INDICATOR_ACTIVE}`;\n    document.querySelectorAll(`.${selIndicators}`).forEach((el) => {\n      el.classList.remove(selIndicators);\n    });\n    this.state.elItems.offsetHeight;\n    this.state.elItems.classList.remove(transitionNoneClass);\n    const index = this.constructor.instances.findIndex((el) => el.target === this.state.el);\n    this.constructor.instances.splice(index, 1);\n  }\n  onClick(e) {\n    if (this.state.isMoving) {\n      e.preventDefault();\n    }\n    if (!(e.target.closest(\".itc-slider-btn\") || e.target.closest(\".itc-slider-indicators\"))) {\n      return;\n    }\n    const classBtnPrev = this.state.prefix + this.constructor.BTN_PREV;\n    const classBtnNext = this.state.prefix + this.constructor.BTN_NEXT;\n    this.autoplay(\"stop\");\n    if (e.target.closest(`.${classBtnPrev}`) || e.target.closest(`.${classBtnNext}`)) {\n      this.state.direction = e.target.closest(`.${classBtnPrev}`) ? \"prev\" : \"next\";\n      this.move();\n    } else if (e.target.dataset.slideTo) {\n      const index = parseInt(e.target.dataset.slideTo, 10);\n      this.moveTo(index);\n    }\n    this.config.loop ? this.autoplay() : null;\n  }\n  onMouseEnter() {\n    this.autoplay(\"stop\");\n  }\n  onMouseLeave() {\n    this.autoplay();\n  }\n  onTransitionStart() {\n    if (this.config.loop) {\n      if (this.state.isBalancing) {\n        return;\n      }\n      this.state.isBalancing = true;\n      window.requestAnimationFrame(() => {\n        this.balanceItems(false);\n      });\n    }\n  }\n  onTransitionEnd() {\n    if (this.config.loop) {\n      this.state.isBalancing = false;\n    }\n  }\n  onDragStart(e) {\n    e.preventDefault();\n  }\n  onVisibilityChange() {\n    if (document.visibilityState === \"hidden\") {\n      this.autoplay(\"stop\");\n    } else if (document.visibilityState === \"visible\" && this.config.loop) {\n      this.autoplay();\n    }\n  }\n  touchStart(e) {\n    this.state.isMoving = false;\n    this.autoplay(\"stop\");\n    const event = e.type.search(\"touch\") === 0 ? e.touches[0] : e;\n    this.state.swipeX = event.clientX;\n    this.state.swipeY = event.clientY;\n    this.state.isSwiping = true;\n    this.state.isTouchMoving = false;\n  }\n  touchEnd(e) {\n    if (!this.state.isSwiping) {\n      return;\n    }\n    const event = e.type.search(\"touch\") === 0 ? e.changedTouches[0] : e;\n    const wrapperRect = this.state.elWrapper.getBoundingClientRect();\n    let clientX = event.clientX < wrapperRect.left ? wrapperRect.left : event.clientX;\n    clientX = clientX > wrapperRect.right ? wrapperRect.right : clientX;\n    let diffPosX = this.state.swipeX - clientX;\n    if (diffPosX === 0) {\n      this.state.isSwiping = false;\n      return;\n    }\n    if (!this.config.loop) {\n      const isNotMoveFirst = this.state.activeItems[0] === 1 && diffPosX <= 0;\n      const isNotMoveLast = this.state.activeItems[this.state.activeItems.length - 1] && diffPosX >= 0;\n      if (isNotMoveFirst || isNotMoveLast) {\n        diffPosX = 0;\n      }\n    }\n    const value = diffPosX / this.state.width * 100;\n    const transitionNoneClass = this.state.prefix + this.constructor.TRANSITION_NONE;\n    this.state.elItems.classList.remove(transitionNoneClass);\n    if (value > this.constructor.SWIPE_THRESHOLD) {\n      this.state.direction = \"next\";\n      let count = 0;\n      while (count <= Math.floor(Math.abs(value) - this.constructor.SWIPE_THRESHOLD) / 100) {\n        this.move();\n        count += 1;\n      }\n    } else if (value < -this.constructor.SWIPE_THRESHOLD) {\n      this.state.direction = \"prev\";\n      let count = 0;\n      while (count <= Math.floor(Math.abs(value) - this.constructor.SWIPE_THRESHOLD) / 100) {\n        this.move();\n        count += 1;\n      }\n    } else {\n      this.state.direction = \"none\";\n      this.move();\n    }\n    this.state.isSwiping = false;\n    if (this.config.loop) {\n      this.autoplay();\n    }\n    this.state.isBalancing = false;\n  }\n  touchMove(e) {\n    if (!this.state.isSwiping) {\n      return;\n    }\n    this.state.isMoving = true;\n    const event = e.type.search(\"touch\") === 0 ? e.changedTouches[0] : e;\n    let diffPosX = this.state.swipeX - event.clientX;\n    const diffPosY = this.state.swipeY - event.clientY;\n    const prevPosX = this.state.prevPosX ? this.state.prevPosX : event.clientX;\n    const direction = prevPosX > event.clientX ? \"next\" : \"prev\";\n    this.state.prevPosX = event.clientX;\n    if (!this.state.isTouchMoving) {\n      if (Math.abs(diffPosY) > Math.abs(diffPosX) || Math.abs(diffPosX) === 0) {\n        this.state.isSwiping = false;\n        return;\n      }\n      this.state.isTouchMoving = true;\n    }\n    e.preventDefault();\n    if (!this.config.loop) {\n      const isNotMoveFirst = this.state.activeItems[0] === 1 && diffPosX <= 0;\n      const isNotMoveLast = this.state.activeItems[this.state.activeItems.length - 1] && diffPosX >= 0;\n      if (isNotMoveFirst || isNotMoveLast) {\n        diffPosX /= 4;\n      }\n    }\n    const transitionNoneClass = this.state.prefix + this.constructor.TRANSITION_NONE;\n    this.state.elItems.classList.add(transitionNoneClass);\n    const translate = this.state.translate - diffPosX;\n    this.state.elItems.style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\n    if (this.config.loop) {\n      this.state.direction = diffPosX > 0 ? \"next\" : \"prev\";\n      this.state.direction = direction;\n      window.requestAnimationFrame(() => {\n        this.balanceItems(true);\n      });\n    }\n  }\n  attachEvents() {\n    this.state.events = {\n      click: [this.state.el, this.onClick.bind(this), true],\n      mouseenter: [this.state.el, this.onMouseEnter.bind(this), true],\n      mouseleave: [this.state.el, this.onMouseLeave.bind(this), true],\n      transitionstart: [this.state.elItems, this.onTransitionStart.bind(this), this.config.loop],\n      transitionend: [this.state.elItems, this.onTransitionEnd.bind(this), this.config.loop],\n      touchstart: [this.state.el, this.touchStart.bind(this), this.config.swipe],\n      mousedown: [this.state.el, this.touchStart.bind(this), this.config.swipe],\n      touchend: [document, this.touchEnd.bind(this), this.config.swipe],\n      mouseup: [document, this.touchEnd.bind(this), this.config.swipe],\n      touchmove: [this.state.el, this.touchMove.bind(this), this.config.swipe],\n      mousemove: [this.state.el, this.touchMove.bind(this), this.config.swipe],\n      dragstart: [this.state.el, this.onDragStart.bind(this), true],\n      visibilitychange: [document, this.onVisibilityChange.bind(this), true]\n    };\n    Object.keys(this.state.events).forEach((type) => {\n      if (this.state.events[type][2]) {\n        const el = this.state.events[type][0];\n        const fn = this.state.events[type][1];\n        if (type === \"touchstart\" || type === \"touchmove\") {\n          const options = this.constructor.checkSupportPassiveEvents() ? { passive: false } : false;\n          el.addEventListener(type, fn, options);\n        } else {\n          el.addEventListener(type, fn);\n        }\n      }\n    });\n    const resizeObserver = new ResizeObserver((entries) => {\n      window.requestAnimationFrame(this.reset.bind(this));\n    });\n    resizeObserver.observe(this.state.elWrapper);\n  }\n  detachEvents() {\n    Object.keys(this.state.events).forEach((type) => {\n      if (this.state.events[type][2]) {\n        const el = this.state.events[type][0];\n        const fn = this.state.events[type][1];\n        el.removeEventListener(type, fn);\n      }\n    });\n  }\n  autoplay(action) {\n    if (!this.config.autoplay) {\n      return;\n    }\n    if (action === \"stop\") {\n      clearInterval(this.state.intervalId);\n      this.state.intervalId = null;\n      return;\n    }\n    if (this.state.intervalId === null) {\n      this.state.intervalId = setInterval(() => {\n        this.state.direction = this.config.direction === \"prev\" ? \"prev\" : \"next\";\n        this.move();\n      }, this.config.interval);\n    }\n  }\n  balanceItems(once = false) {\n    if (!this.state.isBalancing && !once) {\n      return;\n    }\n    const wrapperRect = this.state.elWrapper.getBoundingClientRect();\n    const targetWidth = wrapperRect.width / this.state.countActiveItems / 2;\n    const countItems = this.state.elListItem.length;\n    if (this.state.direction === \"next\") {\n      const exItemRectRight = this.state.exItemMin.getBoundingClientRect().right;\n      if (exItemRectRight < wrapperRect.left - targetWidth) {\n        const elFound = this.state.els.find((item) => item.el === this.state.exItemMin);\n        elFound.order = this.state.exOrderMin + countItems;\n        const translate = this.state.exTranslateMin + countItems * this.state.width;\n        elFound.translate = translate;\n        this.state.exItemMin.style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\n        this.updateExProperties();\n      }\n    } else {\n      const exItemRectLeft = this.state.exItemMax.getBoundingClientRect().left;\n      if (exItemRectLeft > wrapperRect.right + targetWidth) {\n        const elFound = this.state.els.find((item) => item.el === this.state.exItemMax);\n        elFound.order = this.state.exOrderMax - countItems;\n        const translate = this.state.exTranslateMax - countItems * this.state.width;\n        elFound.translate = translate;\n        this.state.exItemMax.style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\n        this.updateExProperties();\n      }\n    }\n    if (!once) {\n      window.requestAnimationFrame(() => {\n        this.balanceItems(false);\n      });\n    }\n  }\n  updateClasses() {\n    const activeClass = this.state.prefix + this.constructor.EL_ITEM_ACTIVE;\n    this.state.activeItems.forEach((item, index) => {\n      if (item) {\n        this.state.elListItem[index].classList.add(activeClass);\n      } else {\n        this.state.elListItem[index].classList.remove(activeClass);\n      }\n      const elListIndicators = this.state.el.querySelectorAll(`.${this.state.prefix}${this.constructor.EL_INDICATOR}`);\n      if (elListIndicators.length && item) {\n        elListIndicators[index].classList.add(`${this.state.prefix}${this.constructor.EL_INDICATOR_ACTIVE}`);\n      } else if (elListIndicators.length && !item) {\n        elListIndicators[index].classList.remove(`${this.state.prefix}${this.constructor.EL_INDICATOR_ACTIVE}`);\n      }\n    });\n  }\n  move() {\n    if (this.state.direction === \"none\") {\n      const transform2 = this.state.translate;\n      this.state.elItems.style.transform = `translate3D(${transform2}px, 0px, 0.1px)`;\n      return;\n    }\n    const widthItem = this.state.direction === \"next\" ? -this.state.width : this.state.width;\n    const transform = this.state.translate + widthItem;\n    if (!this.config.loop) {\n      const limit = this.state.width * (this.state.elListItem.length - this.state.countActiveItems);\n      if (transform < -limit || transform > 0) {\n        return;\n      }\n      if (this.state.btnPrev) {\n        this.state.btnPrev.classList.remove(this.state.btnClassHide);\n        this.state.btnNext.classList.remove(this.state.btnClassHide);\n      }\n      if (this.state.btnPrev && transform === -limit) {\n        this.state.btnNext.classList.add(this.state.btnClassHide);\n      } else if (this.state.btnPrev && transform === 0) {\n        this.state.btnPrev.classList.add(this.state.btnClassHide);\n      }\n    }\n    if (this.state.direction === \"next\") {\n      this.state.activeItems = [...this.state.activeItems.slice(-1), ...this.state.activeItems.slice(0, -1)];\n    } else {\n      this.state.activeItems = [...this.state.activeItems.slice(1), ...this.state.activeItems.slice(0, 1)];\n    }\n    this.updateClasses();\n    this.state.translate = transform;\n    this.state.elItems.style.transform = `translate3D(${transform}px, 0px, 0.1px)`;\n  }\n  moveTo(index) {\n    const delta = this.state.activeItems.reduce((acc, current, currentIndex) => {\n      const diff = current ? index - currentIndex : acc;\n      return Math.abs(diff) < Math.abs(acc) ? diff : acc;\n    }, this.state.activeItems.length);\n    if (delta !== 0) {\n      this.state.direction = delta > 0 ? \"next\" : \"prev\";\n      for (let i = 0; i < Math.abs(delta); i++) {\n        this.move();\n      }\n    }\n  }\n  // приватный метод для выполнения первичной инициализации\n  init() {\n    this.state.els = [];\n    this.state.translate = 0;\n    this.state.activeItems = [];\n    this.state.isBalancing = false;\n    const gap = parseFloat(getComputedStyle(this.state.elItems).gap) || 0;\n    this.state.width = this.state.elListItem[0].getBoundingClientRect().width + gap;\n    const widthWrapper = this.state.elWrapper.getBoundingClientRect().width;\n    this.state.countActiveItems = Math.round(widthWrapper / this.state.width);\n    this.state.elListItem.forEach((el, index) => {\n      el.style.transform = \"\";\n      this.state.activeItems.push(index < this.state.countActiveItems ? 1 : 0);\n      this.state.els.push({\n        el,\n        index,\n        order: index,\n        translate: 0\n      });\n    });\n    if (this.config.loop) {\n      const lastIndex = this.state.elListItem.length - 1;\n      const translate = -(lastIndex + 1) * this.state.width;\n      this.state.elListItem[lastIndex].style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\n      this.state.els[lastIndex].order = -1;\n      this.state.els[lastIndex].translate = translate;\n      this.updateExProperties();\n    } else if (this.state.btnPrev) {\n      this.state.btnPrev.classList.add(this.state.btnClassHide);\n    }\n    this.updateClasses();\n    this.autoplay();\n  }\n  reset() {\n    const transitionNoneClass = this.state.prefix + this.constructor.TRANSITION_NONE;\n    const gap = parseFloat(getComputedStyle(this.state.elItems).gap) || 0;\n    const widthItem = this.state.elListItem[0].getBoundingClientRect().width + gap;\n    const widthWrapper = this.state.elWrapper.getBoundingClientRect().width;\n    const countActiveEls = Math.round(widthWrapper / widthItem);\n    if (widthItem === this.state.width && countActiveEls === this.state.countActiveItems) {\n      return;\n    }\n    this.autoplay(\"stop\");\n    this.state.elItems.classList.add(transitionNoneClass);\n    this.state.elItems.style.transform = \"translate3D(0px, 0px, 0.1px)\";\n    this.init();\n    window.requestAnimationFrame(() => {\n      this.state.elItems.classList.remove(transitionNoneClass);\n    });\n  }\n  updateExProperties() {\n    const els = this.state.els.map((item) => item.el);\n    const orders = this.state.els.map((item) => item.order);\n    this.state.exOrderMin = Math.min(...orders);\n    this.state.exOrderMax = Math.max(...orders);\n    const min = orders.indexOf(this.state.exOrderMin);\n    const max = orders.indexOf(this.state.exOrderMax);\n    this.state.exItemMin = els[min];\n    this.state.exItemMax = els[max];\n    this.state.exTranslateMin = this.state.els[min].translate;\n    this.state.exTranslateMax = this.state.els[max].translate;\n  }\n}\n__publicField(ItcSlider, \"EL_WRAPPER\", \"wrapper\");\n__publicField(ItcSlider, \"EL_ITEMS\", \"items\");\n__publicField(ItcSlider, \"EL_ITEM\", \"item\");\n__publicField(ItcSlider, \"EL_ITEM_ACTIVE\", \"item-active\");\n__publicField(ItcSlider, \"EL_INDICATOR\", \"indicator\");\n__publicField(ItcSlider, \"EL_INDICATOR_ACTIVE\", \"indicator-active\");\n__publicField(ItcSlider, \"BTN_PREV\", \"btn-prev\");\n__publicField(ItcSlider, \"BTN_NEXT\", \"btn-next\");\n__publicField(ItcSlider, \"BTN_HIDE\", \"btn-hide\");\n__publicField(ItcSlider, \"TRANSITION_NONE\", \"transition-none\");\n__publicField(ItcSlider, \"SWIPE_THRESHOLD\", 20);\n__publicField(ItcSlider, \"instances\", []);\nItcSlider.createInstances();\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./main.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;